#include "syscall.h" /* XXX: This is required because SYS_close macro number is defined there for all the syscalls */
#include "traps.h"


/*
   XXX:
   Here all the system call functions are defined

   .global name 			-> symbol name should be treated as a global symbol by the assembler. In other words, it makes name visible and accessible from other parts of the assembly code.
   mov $SYS_ ## name, %rax; -> This line moves the system call number associated with the name into the %rax register. It uses $SYS_ ## name to concatenate the SYS_ prefix with the provided name. For example, if you call SYSCALL(fork), it becomes SYS_fork, which is typically an integer representing the system call number for fork. 
   mov %rcx, %r10 ;			-> This line moves the value of the %rcx register into the %r10 register. The %rcx register might contain function arguments, and this line is used to ensure that the arguments are preserved across the syscall.
   syscall					-> This line is the actual system call instruction. It triggers a switch from user mode to kernel mode and transfers control to the appropriate system call handler based on the value in %rax (which was set in the previous mov instruction).
   ret						-> This line is a return instruction. After the system call has been handled, it returns control to the calling code. (points ip to correct previous value 

   About ret:
    	1. In assembly language, the ret instruction is used to return control from a subroutine or function back to the calling code. When the ret instruction is executed, it performs the following actions:
		Pops the Return Address: It pops the top value from the stack, which typically contains the return address of the calling code. This return address is crucial because it tells the CPU where to resume execution after the subroutine or function completes its execution.
		Jumps to the Return Address: After popping the return address from the stack, the ret instruction jumps to the memory address stored in the return address. This jump effectively transfers control back to the point in the calling code where the subroutine or function was originally called.
		Stack Adjustment: Optionally, the ret instruction can also adjust the stack pointer (%rsp register) to deallocate any local variables or function call-related data stored on the stack during the subroutine's execution. However, the specifics of stack adjustment can vary depending on the calling convention and function prologue/epilogue.
		In the context of a system call in the xv6 operating system, the ret instruction is used to return control to the calling code (typically a user-space program) after the system call handler has executed. The return address popped from the stack points to the instruction in the calling code immediately after the system call. This allows the user-space program to continue its execution from where it left off before making the system call.
		So, in summary, the ret instruction is used to perform the essential task of returning control to the caller and resuming execution after the called subroutine or function completes its task.
		2. The ret instruction is not explicitly implemented in C code; it's a low-level assembly instruction used by the CPU. It's typically generated by the compiler or assembly programmer as part of the function's epilogue.

	
	@flow from	: usr.h systems call
	@flow to	: syscall.c syscall(struct trapframe *tf)
*/

#define SYSCALL(name) \
  .global name; \
  name: \
    mov $SYS_ ## name, %rax; \
    mov %rcx, %r10 ;\
    syscall		  ;\
    ret

SYSCALL(fork)
SYSCALL(exit)
SYSCALL(wait)
SYSCALL(pipe)
SYSCALL(read)
SYSCALL(write)
SYSCALL(close)
SYSCALL(kill)
SYSCALL(exec)
SYSCALL(open)
SYSCALL(mknod)
SYSCALL(unlink)
SYSCALL(fstat)
SYSCALL(link)
SYSCALL(mkdir)
SYSCALL(chdir)
SYSCALL(dup)
SYSCALL(getpid)
SYSCALL(sbrk)
SYSCALL(sleep)
SYSCALL(uptime)
SYSCALL(ioctl)
